#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LineLeft,       sensorLineFollower)
#pragma config(Sensor, in2,    LineCenter,     sensorLineFollower)
#pragma config(Sensor, in3,    LineRight,      sensorLineFollower)
#pragma config(Sensor, in4,    LightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  BumpSensor,     sensorDigitalIn)
#pragma config(Sensor, dgtl2,  InputButton,    sensorDigitalIn)
#pragma config(Sensor, dgtl3,  RightSonar,     sensorSONAR_inch)
#pragma config(Sensor, dgtl5,  LeftSonar,      sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  ServoSonar,     sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  LeftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  RightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           LeftDrive1,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           LeftDrive2,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           RightDrive1,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           RightDrive2,   tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           SonarServo,    tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/************************************/
/* Senior Project                   */
/* V0.10 - Basic Setup              */
/*        April 10th                */
/* V0.11 - Demo                     */
/*        April 11th                */
/* V0.12 - Path Demos               */
/*        April 23rd                */
/* V0.20 - AI Path Finding          */
/*        April 30th                */
/* V0.21 - Path Finding in reality  */
/*        May 6th                   */
/************************************/

/* Constants */
const int 	OBSTACLE_COUNT = 7;
const float	TURN_CONV = 1.0; //Conversion rate for Degrees to encoder value for turning
const float	STAIGHT_CONV = 9.0; //Conversion rate for Inches to encoder values for regular driving
const int 	MAX_PATH_SIZE = 10;//Maximum amount of points a path can be
const int 	GENETIC_SIZE	= 10;
const int		FIELD_WIDTH		= 75;//Width of the field
const int 	FIELD_HEIGHT	= 75;//Height of the field

/* Include Files */
#include "Objects.c";
#include "Control.c";
#include "FieldGeneration.c";
#include "DrivePath.c";
#include "Path.c";

//SetPoints
Target startPoint;
Target endPoint;

//List of Undetermined obstacles
Obstacles obstacles;

//Array of Paths
Path paths[GENETIC_SIZE];
Path bestPaths[2];

#include "Genetic.c";

task main()
{
	//Display Status
	displayStatus(0, "Calibrating Gyro");
	displayStatus(1, "Senior Project");

	//Allow the gyro to calibrate
	calibrateGyro(2000);

	//Display Field Status
	displayStatus(0, "Generating Field");

	//Assign a new field to the robot
	generateObstacles(0, obstacles);

	//Assign new targets to startPoint and endPoint
	//NOTE: Coordinantes start at bottom left
	newTarget(startPoint, 0, 20);
	newTarget(endPoint, 40, 30);

	while(true)
	{
		//Display Setup Status
		displayStatus(0, "Setup Complete");

		//Wait for user
		WaitForButton();

		displayStatus(0, "Finding Path");
		//Setup random paths for the robot
		initializePaths(startPoint, endPoint, obstacles);

		for(int n = 0; n < 10; n++)
		{
			//Save the best paths and reset all the paths
			saveBestPaths();

			//Get New Paths
			breedNewValues(0.1, 0.9, startPoint, endPoint, obstacles);
		}

		displayStatus(0, "Path Found!");

		/*Execute Path*/
		for(int i = 0; i < MAX_PATH_SIZE-1; i++)
		{
			if(paths[0].point[i+1].x == -1 && paths[0].point[i+1].y == -1)
			{
				break;
			}
			driveToPoint(paths[0].point[i], paths[0].point[i+1]);
		}

		wait1Msec(1000);

		for(int i = MAX_PATH_SIZE-2; i >= 0; i--)
		{
			if(!(paths[0].point[i+1].x == -1 && paths[0].point[i+1].y == -1))
			{
				driveToPoint(paths[0].point[i+1], paths[0].point[i]);
			}
		}
	}




}
