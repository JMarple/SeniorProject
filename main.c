#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LineLeft,       sensorLineFollower)
#pragma config(Sensor, in2,    LineCenter,     sensorLineFollower)
#pragma config(Sensor, in3,    LineRight,      sensorLineFollower)
#pragma config(Sensor, in4,    LightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  BumpSensor,     sensorDigitalIn)
#pragma config(Sensor, dgtl2,  InputButton,    sensorDigitalIn)
#pragma config(Sensor, dgtl3,  RightSonar,     sensorSONAR_inch)
#pragma config(Sensor, dgtl5,  LeftSonar,      sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  ServoSonar,     sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  LeftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  RightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           LeftDrive1,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           LeftDrive2,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           RightDrive1,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           RightDrive2,   tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           SonarServo,    tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/************************************/
/* Senior Project                   */
/* V0.10 - Basic Setup              */
/*                                  */
/*                                  */
/*                                  */
/************************************/

/* Constants */
const int 	OBSTACLE_COUNT = 10;
const float	TURN_CONV = 1.0; //Conversion rate for Degrees to encoder value for turning
const float	STAIGHT_CONV = 50.0; //Conversion rate for Inches to encoder values for regular driving

/* Include Files */
#include "Objects.c";
#include "Control.c"

//SetPoints
Target startPoint;
Target endPoint;

//List of Undermined obstacles
Obstacle obstacles[OBSTACLE_COUNT];


//Front Sonar Values
const int FrontSonarCheckAmount = 60;
Data data[FrontSonarCheckAmount];
int lowestID = 0;
int totalID = 0;
int sumID = 0;
task main()
{
	while(true)
	{
		setDriveMotor(0, 0); motor[SonarServo] = 0;

		WaitForButton();
		for(int i = 0; i < FrontSonarCheckAmount; i++)
		{
			motor[SonarServo] = i * (256/FrontSonarCheckAmount) - 127;
			data[i].data = SensorValue[ServoSonar];
			wait1Msec(100);
		}

		lowestID = 0;

		for(int i = 1; i < FrontSonarCheckAmount; i++)
		{
			if( data[i].data <= data[lowestID].data && data[i].data != 0 && data[i].data != -1)
			{
				totalID ++;
				sumID += i;

				if(data[i].data < data[lowestID].data)
				{
					lowestID = i;
					totalID = 0;
					sumID = i;
				}

			}

		}
		Drive(TurnEncoder, 45 - (( (float)sumID/(float)totalID ) /(float)FrontSonarCheckAmount) * 90 , 0, 127, 127, true);
	}
	/*while(true)
	{
		WaitForButton();
		Drive(StraightEncoder, 10, 10, 127, 127, true);
		Drive(TurnEncoder, 180, 0, 127, 127, true);
		Drive(StraightEncoder, 10, 10, 127, 127, true);
	}*/

	/*while(true)
	{
		motor[LeftDrive1] = motor[LeftDrive2] = vexRT[Ch3];
		motor[RightDrive1] = motor[RightDrive2] = vexRT[Ch2];
		motor[SonarServo] = vexRT[Ch1];
	}*/

}
